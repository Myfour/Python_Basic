'''
因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。
在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，
.可以匹配任意字符，要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），
用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符,
\s可以匹配一个空格，也包括一个Tab，
要做更精确地匹配，可以用[]表示范围，[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；
A|B可以匹配A或B，
^表示行的开头，^\d表示必须以数字开头。
$表示行的结束，\d$表示必须以数字结束。
'''
# re模块
# 由于Python的字符串本身也用\转义，所以转义时需要用到两个\\，因此强烈建议使用r前缀，就不必考虑转义了
import re
# re.match()方法判断是否匹配，若成功匹配则会返回一个Match对象，否则返回None
if re.match(r'^\d{3}-\d{3,8}$', '010-54188'):
    print('成功匹配！')
else:
    print('匹配失败！！！')
# 切分字符串
print('---------------------')
print(re.split(r'\s+', 'a b  c     d'))
print(re.split(r'[\s\,\;]+', 'a,b,c;d,  ,;,e'))
# 分组，用()表示的就是要提取的分组（Group）
print('---------------------')
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(m.group(0))  # group(0)代表匹配到的整个字符串
print(m.group(1))  # group(1)代表匹配到的第一个分组
print(m.group(2))

# 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
# 加上问号就能取消贪婪匹配
m2 = re.match(r'^(\d+)(0*)$', '10320040000')
print(m2.groups())
m3 = re.match(r'^(\d+?)(0*)$', '10320040000')
print(m3.groups())
# 练习
pattern = re.compile(r'^([\w.]*)@(\w*)\.com$')
m4 = pattern.match('oz_myx@126.com')
print(m4.groups())
